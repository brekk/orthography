import type { Fusion } from "@/Joiners"
import type { Fission } from "@/Splitters"

import { equals } from "Function"

import J from "@/Joiners"
import { log } from "@/Log"
import S from "@/Splitters"



// export type ReversiblePair = Reversible | Irreversible
export type Pair = Pair(Fission, Fusion)
export type Reversible = Reversible(Pair, Pair)

// interface Reversible a {
//   validate :: Pair a -> ReversiblePair
// }

// create :: Reversible a => Fission -> Fusion -> Pair a
// export create = (fizz, fuse) => Pair($, fizz, fuse)

export camel = Pair(S.camel, J.camel)
export constant = Pair(S.constant, J.constant)
export dot = Pair(S.dot, J.dot)
export kebab = Pair(S.kebab, J.kebab)
export pascal = Pair(S.pascal, J.pascal)
export pascalSnake = Pair(S.pascalSnake, J.pascalSnake)
export path = Pair(S.path, J.path)
export sentence = Pair(S.sentence, J.sentence)
export snake = Pair(S.snake, J.snake)
export space = Pair(S.space, J.space)
export train = Pair(S.train, J.train)

// we need to write a validator,
// consider space -> camel
// vs. camel -> space
// because camel adjusts capitalization,
// and space doesn't care, it's not 1:1
